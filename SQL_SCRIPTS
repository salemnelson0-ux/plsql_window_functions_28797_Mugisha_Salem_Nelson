=====================================
PLSQL-Window Functions Assignment
NAME:Mugisha Salem Nelson
ID: 28797
DATE:08/02/2026
=====================================
-- Create customers table
CREATE TABLE customers (
    customer_id NUMBER PRIMARY KEY,
    customer_name VARCHAR2(100),
    province VARCHAR2(50),
    customer_segment VARCHAR2(20)
);

-- Create routes table
CREATE TABLE routes (
    route_id NUMBER PRIMARY KEY,
    route_name VARCHAR2(100),
    origin_province VARCHAR2(50),
    destination_province VARCHAR2(50),
    distance_km NUMBER,
    average_delivery_time NUMBER
);

-- Create deliveries table
CREATE TABLE deliveries (
    delivery_id NUMBER PRIMARY KEY,
    customer_id NUMBER,
    route_id NUMBER,
    delivery_date DATE,
    on_time_flag NUMBER(1), -- 1 = on time, 0 = late
    delivery_time NUMBER, -- in minutes
    CONSTRAINT fk_customer FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    CONSTRAINT fk_route FOREIGN KEY (route_id) REFERENCES routes(route_id)
);

-- Insert sample data into customers
INSERT INTO customers VALUES (1, 'John Doe', 'Kigali City', 'Premium');
INSERT INTO customers VALUES (2, 'Jane Smith', 'Eastern Province', 'Standard');
INSERT INTO customers VALUES (3, 'Mike Johnson', 'Southern Province', 'Basic');
INSERT INTO customers VALUES (4, 'Sarah Williams', 'Western Province', 'Premium');
INSERT INTO customers VALUES (5, 'Tom Brown', 'Northern Province', 'Standard');

-- Insert sample data into routes
INSERT INTO routes VALUES (101, 'Kigali to Gasabo', 'Kigali City', 'Gasabo', 15, 30);
INSERT INTO routes VALUES (102, 'Kigali to Nyagatare', 'Kigali City', 'Nyagatare', 45, 60);
INSERT INTO routes VALUES (103, 'Kigali to Ruhango', 'Kigali City', 'Ruhango', 60, 90);
INSERT INTO routes VALUES (104, 'Kigali to Gisenyi', 'Kigali City', 'Gisenyi', 75, 120);
INSERT INTO routes VALUES (105, 'Kigali to Musanze', 'Kigali City', 'Musanze', 80, 150);

-- Insert sample data into deliveries
INSERT INTO deliveries VALUES (1001, 1, 101, SYSDATE, 1, 25);
INSERT INTO deliveries VALUES (1002, 2, 102, SYSDATE, 0, 70);
INSERT INTO deliveries VALUES (1003, 3, 103, SYSDATE, 1, 85);
INSERT INTO deliveries VALUES (1004, 4, 104, SYSDATE, 1, 110);
INSERT INTO deliveries VALUES (1005, 5, 105, SYSDATE, 0, 160);
INSERT INTO deliveries VALUES (1006, 1, 101, SYSDATE - 1, 1, 20);
INSERT INTO deliveries VALUES (1007, 2, 102, SYSDATE - 1, 0, 65);
INSERT INTO deliveries VALUES (1008, 3, 103, SYSDATE - 1, 1, 80);
INSERT INTO deliveries VALUES (1009, 4, 104, SYSDATE - 1, 1, 105);
INSERT INTO deliveries VALUES (1010, 5, 105, SYSDATE - 1, 0, 140);

-- Commit changes
COMMIT;

-- Verify data
SELECT * FROM customers;
SELECT * FROM routes;
SELECT * FROM deliveries;

-- ========================================
 STEP 4: SQL JOINS IMPLEMENTATION
-- ========================================

 1. INNER JOIN: Retrieve deliveries with valid customers and routes
 Purpose: Show all successful deliveries with complete customer and route information
SELECT 
    d.delivery_id,
    c.customer_name,
    c.province AS customer_province,
    r.route_name,
    r.origin_province,
    r.destination_province,
    d.delivery_date,
    d.on_time_flag,
    d.delivery_time
FROM deliveries d
INNER JOIN customers c ON d.customer_id = c.customer_id
INNER JOIN routes r ON d.route_id = r.route_id
ORDER BY d.delivery_date DESC, d.delivery_id;

-- Business Interpretation:
-- This query shows all deliveries where both customer and route data exist.
-- It confirms data integrity and helps track which customers use which routes most frequently.
-- Management can use this to identify popular route-customer combinations for service optimization.


-- ========================================
 2. LEFT JOIN: Identify customers who have never made a delivery
 Purpose: Find inactive customers for re-engagement campaigns
SELECT 
    c.customer_id,
    c.customer_name,
    c.province,
    c.customer_segment,
    COUNT(d.delivery_id) AS total_deliveries
FROM customers c
LEFT JOIN deliveries d ON c.customer_id = d.customer_id
GROUP BY c.customer_id, c.customer_name, c.province, c.customer_segment
HAVING COUNT(d.delivery_id) = 0
ORDER BY c.customer_name;

-- Business Interpretation:
-- This query identifies customers who have registered but never used the delivery service.
-- These customers represent untapped potential and should be targeted with promotional campaigns.
-- Marketing can use this list to design re-engagement strategies and understand barriers to first-time usage.


-- ========================================
 3. RIGHT JOIN: Detect routes with no delivery activity
 Purpose: Identify underutilized routes that may need evaluation
SELECT 
    r.route_id,
    r.route_name,
    r.origin_province,
    r.destination_province,
    r.distance_km,
    COUNT(d.delivery_id) AS total_deliveries
FROM deliveries d
RIGHT JOIN routes r ON d.route_id = r.route_id
GROUP BY r.route_id, r.route_name, r.origin_province, r.destination_province, r.distance_km
HAVING COUNT(d.delivery_id) = 0
ORDER BY r.route_name;

-- Business Interpretation:
-- This query reveals routes that exist in the system but have no delivery records.
-- These routes may be newly created, seasonal, or inefficient and require operational review.
-- Management should evaluate whether to discontinue these routes or invest in marketing them to customers.


-- ========================================
-- 4. FULL OUTER JOIN: Compare customers and routes including unmatched records
-- Purpose: Get a complete view of all customers and routes, including those without deliveries
SELECT 
    c.customer_name,
    c.province AS customer_province,
    r.route_name,
    r.origin_province,
    r.destination_province,
    d.delivery_id,
    CASE 
        WHEN d.delivery_id IS NOT NULL THEN 'Active Delivery'
        WHEN c.customer_id IS NOT NULL AND d.delivery_id IS NULL THEN 'Customer Without Delivery'
        WHEN r.route_id IS NOT NULL AND d.delivery_id IS NULL THEN 'Route Without Delivery'
        ELSE 'No Match'
    END AS record_status
FROM customers c
FULL OUTER JOIN deliveries d ON c.customer_id = d.customer_id
FULL OUTER JOIN routes r ON d.route_id = r.route_id
ORDER BY record_status, c.customer_name, r.route_name;

-- Business Interpretation:
-- This comprehensive query shows all possible combinations of customers and routes.
-- It helps identify service gaps where customers exist but aren't using certain routes.
-- Strategic planning can use this to match underutilized routes with potential customer bases in specific provinces.


-- ========================================
-- 5. SELF JOIN: Compare deliveries within the same time period
-- Purpose: Identify delivery time variations on the same route and date
SELECT 
    d1.delivery_id AS delivery_1,
    d1.delivery_time AS time_1,
    d1.on_time_flag AS on_time_1,
    d2.delivery_id AS delivery_2,
    d2.delivery_time AS time_2,
    d2.on_time_flag AS on_time_2,
    ABS(d1.delivery_time - d2.delivery_time) AS time_difference_minutes,
    d1.route_id,
    d1.delivery_date
FROM deliveries d1
JOIN deliveries d2 ON d1.route_id = d2.route_id 
    AND d1.delivery_date = d2.delivery_date
    AND d1.delivery_id < d2.delivery_id
WHERE ABS(d1.delivery_time - d2.delivery_time) > 10
ORDER BY d1.delivery_date DESC, time_difference_minutes DESC;

-- Business Interpretation:
-- This query identifies inconsistencies in delivery times for the same route on the same day.
-- Large time differences suggest operational inefficiencies or external factors affecting performance.
-- Operations managers can investigate routes with high variability to standardize processes and improve reliability.


-- ========================================
-- VERIFICATION QUERIES
-- ========================================

-- Count total records in each table
SELECT 'Customers' AS table_name, COUNT(*) AS total_records FROM customers
UNION ALL
SELECT 'Routes' AS table_name, COUNT(*) AS total_records FROM routes
UNION ALL
SELECT 'Deliveries' AS table_name, COUNT(*) AS total_records FROM deliveries;


-- ========================================
-- STEP 5: WINDOW FUNCTIONS IMPLEMENTATION
-- ========================================

-- ========================================
-- CATEGORY 1: RANKING FUNCTIONS
-- ========================================

-- 1.1 ROW_NUMBER(): Assign unique sequential numbers to deliveries per route
SELECT 
    delivery_id,
    route_id,
    customer_id,
    delivery_date,
    delivery_time,
    ROW_NUMBER() OVER (PARTITION BY route_id ORDER BY delivery_date) AS row_num
FROM deliveries
ORDER BY route_id, row_num;

-- Interpretation:
-- This assigns a unique number to each delivery on a route, ordered by date.
-- Useful for identifying the first, second, third delivery on each route for trend analysis.


-- 1.2 RANK(): Rank routes by average delivery time
SELECT 
    r.route_id,
    r.route_name,
    r.origin_province,
    r.destination_province,
    AVG(d.delivery_time) AS avg_delivery_time,
    RANK() OVER (ORDER BY AVG(d.delivery_time)) AS performance_rank
FROM routes r
JOIN deliveries d ON r.route_id = d.route_id
GROUP BY r.route_id, r.route_name, r.origin_province, r.destination_province
ORDER BY performance_rank;

-- Interpretation:
-- Routes are ranked by average delivery time, with lower times receiving better ranks.
-- This helps identify the most efficient routes and those needing improvement.


-- 1.3 DENSE_RANK(): Rank customers by total deliveries
SELECT 
    c.customer_id,
    c.customer_name,
    c.province,
    COUNT(d.delivery_id) AS total_deliveries,
    DENSE_RANK() OVER (ORDER BY COUNT(d.delivery_id) DESC) AS customer_rank
FROM customers c
JOIN deliveries d ON c.customer_id = d.customer_id
GROUP BY c.customer_id, c.customer_name, c.province
ORDER BY customer_rank;

-- Interpretation:
-- Customers are ranked by delivery frequency using DENSE_RANK to avoid gaps in ranking.
-- This identifies high-value customers who use the service most frequently for loyalty programs.


-- 1.4 PERCENT_RANK(): Calculate percentile rank of delivery times
SELECT 
    delivery_id,
    route_id,
    delivery_time,
    PERCENT_RANK() OVER (ORDER BY delivery_time) AS percentile_rank,
    ROUND(PERCENT_RANK() OVER (ORDER BY delivery_time) * 100, 2) AS percentile
FROM deliveries
ORDER BY delivery_time;

-- Interpretation:
-- Shows where each delivery falls in the distribution of delivery times as a percentile.
-- Deliveries in the lower percentiles are faster, while higher percentiles indicate slower deliveries.


-- ========================================
-- CATEGORY 2: AGGREGATE WINDOW FUNCTIONS
-- ========================================

-- 2.1 SUM() with ROWS frame: Running total of deliveries per route
SELECT 
    delivery_id,
    route_id,
    delivery_date,
    delivery_time,
    SUM(delivery_time) OVER (
        PARTITION BY route_id 
        ORDER BY delivery_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total_time
FROM deliveries
ORDER BY route_id, delivery_date;

-- Interpretation:
-- Calculates cumulative delivery time for each route over time using ROWS frame.
-- Helps track total time invested in each route and identify routes requiring more resources.


-- 2.2 AVG() with RANGE frame: Moving average of delivery times
SELECT 
    delivery_id,
    route_id,
    delivery_date,
    delivery_time,
    AVG(delivery_time) OVER (
        PARTITION BY route_id 
        ORDER BY delivery_date 
        RANGE BETWEEN INTERVAL '2' DAY PRECEDING AND CURRENT ROW
    ) AS three_day_moving_avg
FROM deliveries
ORDER BY route_id, delivery_date;

-- Interpretation:
-- Calculates a 3-day moving average of delivery times using RANGE frame for time-based windows.
-- Smooths out daily fluctuations to reveal underlying trends in route performance.


-- 2.3 MIN() and MAX(): Track best and worst delivery times per route
SELECT 
    delivery_id,
    route_id,
    delivery_date,
    delivery_time,
    MIN(delivery_time) OVER (PARTITION BY route_id) AS best_time_on_route,
    MAX(delivery_time) OVER (PARTITION BY route_id) AS worst_time_on_route,
    delivery_time - MIN(delivery_time) OVER (PARTITION BY route_id) AS difference_from_best
FROM deliveries
ORDER BY route_id, delivery_date;

-- Interpretation:
-- Shows the best and worst delivery times for each route alongside current performance.
-- Helps identify performance variability and set realistic delivery time expectations.


-- 2.4 SUM() with ROWS frame: Calculate percentage contribution
SELECT 
    c.customer_id,
    c.customer_name,
    COUNT(d.delivery_id) AS customer_deliveries,
    SUM(COUNT(d.delivery_id)) OVER () AS total_deliveries,
    ROUND(COUNT(d.delivery_id) * 100.0 / SUM(COUNT(d.delivery_id)) OVER (), 2) AS percentage_contribution
FROM customers c
JOIN deliveries d ON c.customer_id = d.customer_id
GROUP BY c.customer_id, c.customer_name
ORDER BY customer_deliveries DESC;

-- Interpretation:
-- Calculates each customer's contribution to total delivery volume as a percentage.
-- Identifies which customers drive the most business for targeted retention strategies.


-- ========================================
-- CATEGORY 3: NAVIGATION FUNCTIONS
-- ========================================

-- 3.1 LAG(): Compare current delivery time with previous delivery on same route
SELECT 
    delivery_id,
    route_id,
    delivery_date,
    delivery_time,
    LAG(delivery_time, 1) OVER (PARTITION BY route_id ORDER BY delivery_date) AS previous_delivery_time,
    delivery_time - LAG(delivery_time, 1) OVER (PARTITION BY route_id ORDER BY delivery_date) AS time_change
FROM deliveries
ORDER BY route_id, delivery_date;

-- Interpretation:
-- Compares each delivery time with the previous delivery on the same route.
-- Positive values indicate slower deliveries, negative values indicate improvement over time.


-- 3.2 LEAD(): Predict next delivery time trend
SELECT 
    delivery_id,
    route_id,
    delivery_date,
    delivery_time,
    LEAD(delivery_time, 1) OVER (PARTITION BY route_id ORDER BY delivery_date) AS next_delivery_time,
    LEAD(delivery_time, 1) OVER (PARTITION BY route_id ORDER BY delivery_date) - delivery_time AS projected_change
FROM deliveries
ORDER BY route_id, delivery_date;

-- Interpretation:
-- Shows the next delivery time on the same route to identify forward-looking trends.
-- Helps predict whether performance is improving or declining for proactive management.


-- 3.3 LAG() and LEAD(): Calculate growth rate between periods
SELECT 
    delivery_id,
    route_id,
    delivery_date,
    on_time_flag,
    LAG(on_time_flag, 1) OVER (PARTITION BY route_id ORDER BY delivery_date) AS prev_on_time,
    LEAD(on_time_flag, 1) OVER (PARTITION BY route_id ORDER BY delivery_date) AS next_on_time,
    CASE 
        WHEN LAG(on_time_flag, 1) OVER (PARTITION BY route_id ORDER BY delivery_date) = 0 
             AND on_time_flag = 1 THEN 'Improved'
        WHEN LAG(on_time_flag, 1) OVER (PARTITION BY route_id ORDER BY delivery_date) = 1 
             AND on_time_flag = 0 THEN 'Declined'
        ELSE 'Stable'
    END AS performance_trend
FROM deliveries
ORDER BY route_id, delivery_date;

-- Interpretation:
-- Tracks whether on-time performance is improving, declining, or stable compared to previous delivery.
-- Helps identify routes with consistent problems or recent improvements requiring attention.


-- ========================================
-- CATEGORY 4: DISTRIBUTION FUNCTIONS
-- ========================================

-- 4.1 NTILE(4): Segment customers into quartiles by delivery frequency
SELECT 
    c.customer_id,
    c.customer_name,
    c.province,
    c.customer_segment,
    COUNT(d.delivery_id) AS total_deliveries,
    NTILE(4) OVER (ORDER BY COUNT(d.delivery_id) DESC) AS customer_quartile
FROM customers c
JOIN deliveries d ON c.customer_id = d.customer_id
GROUP BY c.customer_id, c.customer_name, c.province, c.customer_segment
ORDER BY customer_quartile, total_deliveries DESC;

-- Interpretation:
-- Divides customers into four equal groups based on delivery frequency.
-- Quartile 1 represents top customers, Quartile 4 represents least active customers for targeted strategies.


-- 4.2 CUME_DIST(): Calculate cumulative distribution of delivery times
SELECT 
    delivery_id,
    route_id,
    delivery_time,
    CUME_DIST() OVER (ORDER BY delivery_time) AS cumulative_distribution,
    ROUND(CUME_DIST() OVER (ORDER BY delivery_time) * 100, 2) AS cumulative_percentage
FROM deliveries
ORDER BY delivery_time;

-- Interpretation:
-- Shows the cumulative percentage of deliveries at or below each delivery time.
-- Helps set service level agreements (SLAs) based on realistic performance distributions.


-- 4.3 NTILE(4): Segment routes by performance quartiles
SELECT 
    r.route_id,
    r.route_name,
    AVG(d.delivery_time) AS avg_delivery_time,
    NTILE(4) OVER (ORDER BY AVG(d.delivery_time)) AS performance_quartile
FROM routes r
JOIN deliveries d ON r.route_id = d.route_id
GROUP BY r.route_id, r.route_name
ORDER BY performance_quartile, avg_delivery_time;

-- Interpretation:
-- Segments routes into performance quartiles where Quartile 1 has fastest delivery times.
-- Management can focus resources on improving Quartile 4 routes while maintaining Quartile 1 standards.


-- 4.4 CUME_DIST() with NTILE(): Combined customer segmentation analysis
SELECT 
    c.customer_id,
    c.customer_name,
    COUNT(d.delivery_id) AS total_deliveries,
    NTILE(4) OVER (ORDER BY COUNT(d.delivery_id) DESC) AS quartile,
    ROUND(CUME_DIST() OVER (ORDER BY COUNT(d.delivery_id) DESC) * 100, 2) AS cumulative_pct
FROM customers c
JOIN deliveries d ON c.customer_id = d.customer_id
GROUP BY c.customer_id, c.customer_name
ORDER BY total_deliveries DESC;

-- Interpretation:
-- Combines quartile segmentation with cumulative distribution for comprehensive customer analysis.
-- Shows both the customer's quartile group and their exact position in the overall distribution.

end

